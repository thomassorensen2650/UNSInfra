@using UNSInfra.Services.TopicBrowser
@using UNSInfra.Models.Hierarchy
@using UNSInfra.Services
@inject IHierarchyService HierarchyService

<style>
.topic-tree {
    list-style-type: none;
    padding-left: 1em;
}

.tab-content {
    max-height: 600px; /* Set a reasonable maximum height */
}

.nav-tabs .nav-link {
    font-size: 0.875rem;
    padding: 0.5rem 1rem;
}

.nav-tabs .nav-link.active {
    background-color: #fff;
    border-color: #dee2e6 #dee2e6 #fff;
}

.tab-pane {
    max-height: 560px; /* Subtract tab height from max height */
    overflow-y: auto;
}
</style>

<!-- Tab Navigation -->
<ul class="nav nav-tabs" id="topicTabs" role="tablist">
    <li class="nav-item" role="presentation">
        <button class="nav-link @(activeTab == "ns" ? "active" : "")" id="ns-tab" type="button" role="tab" 
                @onclick="@(() => SetActiveTab("ns"))">
            üèóÔ∏è UNS
        </button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link @(activeTab == "unverified" ? "active" : "")" id="unverified-tab" type="button" role="tab"
                @onclick="@(() => SetActiveTab("unverified"))">
            üìä Data Browser
        </button>
    </li>
</ul>

<!-- Tab Content -->
<div class="tab-content">
    <div class="tab-pane @(activeTab == "ns" ? "show active" : "")" id="ns-pane" role="tabpanel">
        <NSTreeEditor OnAddDataToNamespace="HandleAddDataToNamespace" OnTopicSelected="HandleTopicSelected" />
    </div>
    
    <div class="tab-pane @(activeTab == "unverified" ? "show active" : "")" id="unverified-pane" role="tabpanel">
        @if (UnverifiedNodes.Any())
        {
            <ul class="topic-tree">
                @foreach (var node in UnverifiedNodes)
                {
                    <TopicTreeNodeWithNS Node="node" HighlightedPaths="HighlightedPaths" SelectedNodePath="@SelectedNodePath" OnTopicSelected="HandleTopicSelected" OnToggleExpanded="ToggleExpansion" />
                }
            </ul>
        }
        else
        {
            <div class="text-center py-4">
                <i class="bi bi-database text-muted" style="font-size: 2rem;"></i>
                <p class="text-muted mt-2">No data found</p>
                <small class="text-muted">Data will appear here when received from data sources</small>
            </div>
        }
    </div>
</div>

@code {
    [Parameter] public List<TopicInfo> Topics { get; set; } = new();
    [Parameter] public HashSet<string> HighlightedPaths { get; set; } = new();
    [Parameter] public EventCallback<TopicInfo> OnTopicSelected { get; set; }
    [Parameter] public EventCallback<(string namespacePath, List<TopicInfo> topics)> OnAddDataToNamespace { get; set; }
    [Parameter] public int MaxVisibleTopics { get; set; } = 1000; // Limit visible topics for performance
    [Parameter] public int MaxUnverifiedTopicsPerPage { get; set; } = 100; // Paginate unverified topics
    
    private string? SelectedNodePath { get; set; }
    private string activeTab = "ns"; // Default to NS Structure tab

    private List<TopicTreeNodeModel> RootNodes = new();
    private List<TopicTreeNodeModel> UnverifiedNodes = new();
    private Dictionary<string, TopicTreeNodeModel> NodeLookup = new();
    private Dictionary<string, List<TopicInfo>> TopicsByPath = new();
    private Dictionary<string, List<string>> ChildrenLookup = new(); // Parent path -> immediate child names (ordered)
    private int _lastTopicsHash = 0;
    private readonly Dictionary<string, DateTime> _expansionCooldowns = new(); // Prevent rapid successive clicks
    private int _lastTopicsCount = 0; // Track if we're just adding new topics

    protected override async Task OnParametersSetAsync()
    {
        // Check if we're just adding new topics or if there are other changes
        var currentHash = GetTopicsHashCode();
        
        if (currentHash != _lastTopicsHash)
        {
            var currentCount = Topics?.Count ?? 0;
            bool isJustAddingTopics = currentCount > _lastTopicsCount && 
                                      _lastTopicsCount > 0 && // Not initial load
                                      currentCount - _lastTopicsCount <= 5; // Only a few new topics
            
            if (isJustAddingTopics)
            {
                // Incremental update - just add new topics without full rebuild
                await AddNewTopicsIncrementally();
            }
            else
            {
                // Full rebuild needed
                var expansionState = SaveExpansionState();
                var selectedPath = SelectedNodePath;
                
                await BuildTreeStructure(Topics ?? new List<TopicInfo>());
                
                RestoreExpansionState(expansionState);
                SelectedNodePath = selectedPath;
            }
            
            _lastTopicsHash = currentHash;
            _lastTopicsCount = currentCount;
        }
    }
    
    private int GetTopicsHashCode()
    {
        if (Topics == null || Topics.Count == 0) 
            return 0;
            
        var hash = Topics.Count;
        foreach (var topic in Topics)
        {
            hash = hash * 31 + topic.Topic.GetHashCode();
            hash = hash * 31 + topic.Path.GetFullPath().GetHashCode();
            hash = hash * 31 + topic.IsVerified.GetHashCode();
            hash = hash * 31 + topic.SourceType.GetHashCode();
        }
        return hash;
    }
    
    private async Task AddNewTopicsIncrementally()
    {
        // Get the new topics (assuming they're at the end of the list)
        var newTopics = Topics.Skip(_lastTopicsCount).ToList();
        var newVerifiedTopics = newTopics.Where(t => t.IsVerified).ToList();
        var newUnverifiedTopics = newTopics.Where(t => !t.IsVerified).ToList();
        
        // Add new verified topics using hierarchical structure
        foreach (var topic in newVerifiedTopics)
        {
            var pathParts = await GetPathPartsAsync(topic.Path);
            string currentPath = "";
            
            // Build the hierarchical path structure and store topic data at the final level
            for (int i = 0; i < pathParts.Length; i++)
            {
                if (string.IsNullOrEmpty(pathParts[i])) break;
                
                var parentPath = currentPath;
                currentPath = string.IsNullOrEmpty(currentPath) ? pathParts[i] : $"{currentPath}/{pathParts[i]}";
                
                if (!TopicsByPath.ContainsKey(currentPath))
                    TopicsByPath[currentPath] = new List<TopicInfo>();
                
                // Build children lookup for fast expansion (maintain order)
                if (!ChildrenLookup.ContainsKey(parentPath))
                    ChildrenLookup[parentPath] = new List<string>();
                if (!ChildrenLookup[parentPath].Contains(pathParts[i]))
                    ChildrenLookup[parentPath].Add(pathParts[i]);
            }
            
            // Store the topic data directly at the hierarchical path level
            // The property name (like "value") is already part of the topic name
            TopicsByPath[currentPath].Add(topic);
        }
        
        // Add new unverified topics using folder structure grouped by source type
        if (newUnverifiedTopics.Count > 0)
        {
            const string unverifiedSectionName = "üîç Unverified Topics";
            
            // Ensure unverified section exists
            if (!ChildrenLookup.ContainsKey(""))
                ChildrenLookup[""] = new List<string>();
            if (!ChildrenLookup[""].Contains(unverifiedSectionName))
                ChildrenLookup[""].Add(unverifiedSectionName);
            
            if (!ChildrenLookup.ContainsKey(unverifiedSectionName))
                ChildrenLookup[unverifiedSectionName] = new List<string>();
            if (!TopicsByPath.ContainsKey(unverifiedSectionName))
                TopicsByPath[unverifiedSectionName] = new List<TopicInfo>();
            
            // Group unverified topics by source type, then build folder structure
            var topicsBySourceType = newUnverifiedTopics.GroupBy(t => t.SourceType).ToList();
            
            foreach (var sourceGroup in topicsBySourceType)
            {
                var sourceType = sourceGroup.Key;
                var sourcePath = $"{unverifiedSectionName}/{sourceType}";
                
                // Ensure source type folder exists
                if (!ChildrenLookup[unverifiedSectionName].Contains(sourceType))
                {
                    ChildrenLookup[unverifiedSectionName].Add(sourceType);
                }
                if (!ChildrenLookup.ContainsKey(sourcePath))
                    ChildrenLookup[sourcePath] = new List<string>();
                if (!TopicsByPath.ContainsKey(sourcePath))
                    TopicsByPath[sourcePath] = new List<TopicInfo>();
                
                // Build folder structure for each topic within this source type
                foreach (var topic in sourceGroup)
                {
                    var topicParts = topic.Topic.Split('/', StringSplitOptions.RemoveEmptyEntries);
                    
                    // If topic has no separators (flat topic name), treat it as a single item
                    if (topicParts.Length == 1)
                    {
                        var topicKey = $"{sourcePath}/{topic.Topic}";
                        if (!ChildrenLookup[sourcePath].Contains(topic.Topic))
                        {
                            ChildrenLookup[sourcePath].Add(topic.Topic);
                            TopicsByPath[topicKey] = new List<TopicInfo> { topic };
                        }
                    }
                    else
                    {
                        // Build nested folder structure based on topic path segments
                        string currentPath = sourcePath;
                        
                        for (int i = 0; i < topicParts.Length; i++)
                        {
                            var part = topicParts[i];
                            var parentPath = currentPath;
                            currentPath = $"{currentPath}/{part}";
                            
                            // Initialize path structures if they don't exist
                            if (!TopicsByPath.ContainsKey(currentPath))
                                TopicsByPath[currentPath] = new List<TopicInfo>();
                            
                            if (!ChildrenLookup.ContainsKey(parentPath))
                                ChildrenLookup[parentPath] = new List<string>();
                            
                            // Add this part as a child of the parent path
                            if (!ChildrenLookup[parentPath].Contains(part))
                                ChildrenLookup[parentPath].Add(part);
                            
                            // If this is the final segment, store the actual topic data
                            if (i == topicParts.Length - 1)
                            {
                                TopicsByPath[currentPath].Add(topic);
                            }
                        }
                    }
                }
            }
        }
        
        // Update existing nodes that might now have new children
        UpdateNodesWithNewChildren();
    }
    
    private void UpdateNodesWithNewChildren()
    {
        // Update existing nodes that might now have children
        foreach (var node in NodeLookup.Values)
        {
            if (!node.HasChildren && ChildrenLookup.ContainsKey(node.FullPath) && ChildrenLookup[node.FullPath].Count > 0)
            {
                node.HasChildren = true;
            }
        }
        
        // Add any new root nodes
        var rootChildNames = ChildrenLookup.GetValueOrDefault("", new List<string>());
        var existingRootNames = RootNodes.Select(n => n.Name).ToHashSet();
        
        foreach (var childName in rootChildNames)
        {
            if (!existingRootNames.Contains(childName))
            {
                var node = CreateNode(childName, childName);
                RootNodes.Add(node); // Add new nodes at the bottom
                NodeLookup[childName] = node;
            }
        }
    }

    private void SetActiveTab(string tabName)
    {
        activeTab = tabName;
        StateHasChanged();
    }

    private async Task HandleAddDataToNamespace(string namespacePath)
    {
        // Get topics that are not yet assigned to namespaces for selection
        var availableTopics = Topics.Where(t => string.IsNullOrEmpty(t.NSPath)).ToList();
        await OnAddDataToNamespace.InvokeAsync((namespacePath, availableTopics));
    }

    private async Task BuildTreeStructure(List<TopicInfo> topics)
    {
        NodeLookup.Clear();
        TopicsByPath.Clear();
        ChildrenLookup.Clear();
        
        // Clear all node collections
        UnverifiedNodes.Clear();

        // Separate topics for different display strategies
        // For Data Browser: show topics that are NOT assigned to namespaces (regardless of verified status)
        var unverifiedTopics = topics.Where(t => string.IsNullOrEmpty(t.NSPath)).OrderBy(t => t.CreatedAt).ToList();
        
        // For hierarchical tree display: show topics that are verified but NOT assigned to namespaces
        var verifiedTopics = topics.Where(t => t.IsVerified && string.IsNullOrEmpty(t.NSPath)).OrderBy(t => t.CreatedAt).ToList();
        

        // Process verified topics using hierarchical structure
        foreach (var topic in verifiedTopics)
        {
            var pathParts = await GetPathPartsAsync(topic.Path);
            string currentPath = "";
            
            // Build the hierarchical path structure and store topic data at the final level
            for (int i = 0; i < pathParts.Length; i++)
            {
                if (string.IsNullOrEmpty(pathParts[i])) break;
                
                var parentPath = currentPath;
                currentPath = string.IsNullOrEmpty(currentPath) ? pathParts[i] : $"{currentPath}/{pathParts[i]}";
                
                if (!TopicsByPath.ContainsKey(currentPath))
                    TopicsByPath[currentPath] = new List<TopicInfo>();
                
                // Build children lookup for fast expansion (maintain order)
                if (!ChildrenLookup.ContainsKey(parentPath))
                    ChildrenLookup[parentPath] = new List<string>();
                if (!ChildrenLookup[parentPath].Contains(pathParts[i]))
                    ChildrenLookup[parentPath].Add(pathParts[i]);
            }
            
            // Store the topic data directly at the hierarchical path level
            // The property name (like "value") is already part of the topic name
            TopicsByPath[currentPath].Add(topic);
        }

        // Add NS (Namespace Structure) section - but don't populate it here
        // The NS section will be handled by the NSTreeEditor component
        const string nsSectionName = "üìÅ NS";
        if (!ChildrenLookup.ContainsKey(""))
            ChildrenLookup[""] = new List<string>();
        if (!ChildrenLookup[""].Contains(nsSectionName))
            ChildrenLookup[""].Insert(0, nsSectionName); // Insert at beginning

        // Initialize NS section as placeholder - actual editing happens in NSTreeEditor
        if (!ChildrenLookup.ContainsKey(nsSectionName))
            ChildrenLookup[nsSectionName] = new List<string>();
        if (!TopicsByPath.ContainsKey(nsSectionName))
            TopicsByPath[nsSectionName] = new List<TopicInfo>();

        // Always create unverified topics section, even if empty initially
        const string unverifiedSectionName = "üîç Unverified Topics";
        
        // Add unverified section to root
        if (!ChildrenLookup.ContainsKey(""))
            ChildrenLookup[""] = new List<string>();
        if (!ChildrenLookup[""].Contains(unverifiedSectionName))
            ChildrenLookup[""].Add(unverifiedSectionName);
        
        // Initialize unverified section
        if (!ChildrenLookup.ContainsKey(unverifiedSectionName))
            ChildrenLookup[unverifiedSectionName] = new List<string>();
        if (!TopicsByPath.ContainsKey(unverifiedSectionName))
            TopicsByPath[unverifiedSectionName] = new List<TopicInfo>();

        // Process unverified topics using folder structure grouped by source type
        if (unverifiedTopics.Count > 0)
        {
            
            // Group unverified topics by source type, then build folder structure
            var topicsBySourceType = unverifiedTopics.GroupBy(t => t.SourceType).ToList();
            
            foreach (var sourceGroup in topicsBySourceType)
            {
                var sourceType = sourceGroup.Key;
                var sourcePath = $"{unverifiedSectionName}/{sourceType}";
                
                // Ensure source type folder exists
                if (!ChildrenLookup[unverifiedSectionName].Contains(sourceType))
                {
                    ChildrenLookup[unverifiedSectionName].Add(sourceType);
                }
                if (!ChildrenLookup.ContainsKey(sourcePath))
                    ChildrenLookup[sourcePath] = new List<string>();
                if (!TopicsByPath.ContainsKey(sourcePath))
                    TopicsByPath[sourcePath] = new List<TopicInfo>();
                
                // Build folder structure for each topic within this source type
                foreach (var topic in sourceGroup)
                {
                    var topicParts = topic.Topic.Split('/', StringSplitOptions.RemoveEmptyEntries);
                    
                    // If topic has no separators (flat topic name), treat it as a single item
                    if (topicParts.Length == 1)
                    {
                        var topicKey = $"{sourcePath}/{topic.Topic}";
                        if (!ChildrenLookup[sourcePath].Contains(topic.Topic))
                        {
                            ChildrenLookup[sourcePath].Add(topic.Topic);
                            TopicsByPath[topicKey] = new List<TopicInfo> { topic };
                        }
                    }
                    else
                    {
                        // Build nested folder structure based on topic path segments
                        string currentPath = sourcePath;
                        
                        for (int i = 0; i < topicParts.Length; i++)
                        {
                            var part = topicParts[i];
                            var parentPath = currentPath;
                            currentPath = $"{currentPath}/{part}";
                            
                            // Initialize path structures if they don't exist
                            if (!TopicsByPath.ContainsKey(currentPath))
                                TopicsByPath[currentPath] = new List<TopicInfo>();
                            
                            if (!ChildrenLookup.ContainsKey(parentPath))
                                ChildrenLookup[parentPath] = new List<string>();
                            
                            // Add this part as a child of the parent path
                            if (!ChildrenLookup[parentPath].Contains(part))
                                ChildrenLookup[parentPath].Add(part);
                            
                            // If this is the final segment, store the actual topic data
                            if (i == topicParts.Length - 1)
                            {
                                TopicsByPath[currentPath].Add(topic);
                            }
                        }
                    }
                }
            }
        }

        // Build separate node collections for tabs
        BuildUnverifiedTreeStructure(unverifiedTopics);

        // Keep the original root nodes for compatibility
        var rootChildNames = ChildrenLookup.GetValueOrDefault("", new List<string>());
        var root = new List<TopicTreeNodeModel>();
        foreach (var childName in rootChildNames)
        {
            var node = CreateNode(childName, childName);
            root.Add(node);
            NodeLookup[childName] = node;
        }
        RootNodes = root;
    }

    private TopicTreeNodeModel CreateNode(string name, string fullPath)
    {
        var hasData = TopicsByPath.ContainsKey(fullPath) && TopicsByPath[fullPath].Any();
        var hasChildren = ChildrenLookup.ContainsKey(fullPath) && ChildrenLookup[fullPath].Count > 0;
        
        // Special case: NS folder should always be expandable to show the NSTreeEditor
        if (name == "üìÅ NS")
        {
            hasChildren = true;
        }
        
        // Special case: Unverified Topics folder should always be expandable 
        if (name == "üîç Unverified Topics")
        {
            hasChildren = true;
        }
        
        return new TopicTreeNodeModel
        {
            Name = name,
            FullPath = fullPath,
            Children = new List<TopicTreeNodeModel>(),
            Topic = hasData ? TopicsByPath[fullPath].FirstOrDefault() : null,
            HasChildren = hasChildren,
            ChildrenLoaded = false,
            IsExpanded = false
        };
    }


    private async Task<string[]> GetPathPartsAsync(HierarchicalPath path)
    {
        var hierarchyLevels = await HierarchyService.GetHierarchyLevelsAsync();
        var parts = new List<string>();
        
        foreach (var level in hierarchyLevels)
        {
            var value = path.GetValue(level);
            parts.Add(value);
        }
        
        return parts.ToArray();
    }
    
    private string ExtractPropertyName(string topicName)
    {
        // Extract the property name from the topic
        // For topics like "virtualfactory/update/Enterprise/Dallas/BU/value", extract "value"
        var parts = topicName.Split('/');
        return parts.Length > 0 ? parts[parts.Length - 1] : "";
    }


    public async Task ToggleExpansion(TopicTreeNodeModel node)
    {
        if (!node.HasChildren) return;
        
        // Debounce rapid clicks
        var now = DateTime.UtcNow;
        if (_expansionCooldowns.TryGetValue(node.FullPath, out var lastExpansion) && 
            (now - lastExpansion).TotalMilliseconds < 200)
        {
            return; // Ignore rapid successive clicks
        }
        _expansionCooldowns[node.FullPath] = now;
        
        // Handle collapse immediately
        if (node.IsExpanded)
        {
            node.IsExpanded = false;
            StateHasChanged();
            return;
        }
        
        // Handle expansion with loading state
        if (!node.ChildrenLoaded)
        {
            // Show loading indicator IMMEDIATELY before any async operations
            node.IsLoadingChildren = true;
            node.IsExpanded = true;
            StateHasChanged(); // Force immediate UI update
            
            // Force the UI to render immediately
            await Task.Yield();
            
            try
            {
                // Load children on the current thread (it's already fast)
                LoadChildren(node);
                
                // Update state after loading
                node.IsLoadingChildren = false;
                StateHasChanged();
            }
            catch (Exception)
            {
                node.IsLoadingChildren = false;
                node.IsExpanded = false; // Revert on error
                StateHasChanged();
            }
        }
        else
        {
            // Just expand if already loaded
            node.IsExpanded = true;
            StateHasChanged();
        }
    }

    private void LoadChildren(TopicTreeNodeModel node)
    {
        // Use fast lookup instead of iterating through all paths
        var childNames = ChildrenLookup.GetValueOrDefault(node.FullPath, new List<string>());
        node.Children.Clear();
        
        // Pre-allocate collection for better performance
        var newChildren = new List<TopicTreeNodeModel>(childNames.Count);
        
        foreach (var childName in childNames)
        {
            var childFullPath = string.IsNullOrEmpty(node.FullPath) ? childName : $"{node.FullPath}/{childName}";
            var childNode = CreateNode(childName, childFullPath);
            newChildren.Add(childNode);
            NodeLookup[childFullPath] = childNode;
        }
        
        node.Children = newChildren;
        node.ChildrenLoaded = true;
    }

    public async Task BlinkNode(string path)
    {
        // Start blinking all nodes in the path hierarchy from root to leaf
        await BlinkNodeHierarchy(path);
    }
    
    private async Task BlinkNodeHierarchy(string fullPath)
    {
        return;
        // Get all parent paths including the target path
        var paths = GetAllPathLevels(fullPath);
        
        // Blink nodes from root to leaf
        foreach (var path in paths)
        {
            if (NodeLookup.TryGetValue(path, out var node))
            {
                // Start blinking animation
                node.IsBlinking = true;
                await InvokeAsync(StateHasChanged);
                
                // Small delay to create cascade effect
                await Task.Delay(100);
            }
        }
        
        // Wait for the full animation duration
        await Task.Delay(500);
        
        // Stop blinking all nodes
        foreach (var path in paths)
        {
            if (NodeLookup.TryGetValue(path, out var node))
            {
                node.IsBlinking = false;
            }
        }
        
        await InvokeAsync(StateHasChanged);
    }
    
    private List<string> GetAllPathLevels(string fullPath)
    {
        var parts = fullPath.Split('/', StringSplitOptions.RemoveEmptyEntries);
        var paths = new List<string>();
        var currentPath = "";
        
        foreach (var part in parts)
        {
            currentPath = string.IsNullOrEmpty(currentPath) ? part : $"{currentPath}/{part}";
            paths.Add(currentPath);
        }
        
        return paths;
    }


    private void BuildUnverifiedTreeStructure(List<TopicInfo> unverifiedTopics)
    {
        if (!unverifiedTopics.Any()) return;

        // Group unverified topics by source type
        var topicsBySourceType = unverifiedTopics.GroupBy(t => t.SourceType).ToList();

        foreach (var sourceGroup in topicsBySourceType)
        {
            var sourceType = sourceGroup.Key;
            var sourceNode = new TopicTreeNodeModel
            {
                Name = sourceType,
                FullPath = sourceType,
                Children = new List<TopicTreeNodeModel>(),
                HasChildren = true,
                ChildrenLoaded = false,
                IsExpanded = false
            };

            // Build folder structure for each topic within this source type
            foreach (var topic in sourceGroup)
            {
                var topicNode = new TopicTreeNodeModel
                {
                    Name = topic.Topic,
                    FullPath = $"{sourceType}/{topic.Topic}",
                    Topic = topic,
                    HasChildren = false,
                    ChildrenLoaded = true,
                    IsExpanded = false
                };
                sourceNode.Children.Add(topicNode);
            }

            UnverifiedNodes.Add(sourceNode);
        }
    }




    private string GetParentPath(string path)
    {
        var lastSlash = path.LastIndexOf('/');
        return lastSlash > 0 ? path.Substring(0, lastSlash) : "";
    }

    private async Task HandleTopicSelected(TopicInfo topic)
    {
        try
        {
            // Handle selection differently for verified vs unverified topics
            if (topic.IsVerified)
            {
                // For verified topics, use hierarchical path structure
                var pathParts = await GetPathPartsAsync(topic.Path);
                var parts = pathParts.Where(p => !string.IsNullOrEmpty(p)).ToArray();
                SelectedNodePath = string.Join("/", parts);
            }
            else
            {
                // For unverified topics, use the topic path under the source type folder
                const string unverifiedSectionName = "üîç Unverified Topics";
                SelectedNodePath = $"{unverifiedSectionName}/{topic.SourceType}/{topic.Topic}";
            }
            
            // First invoke the callback to update the parent component
            await OnTopicSelected.InvokeAsync(topic);
            
            // Then force immediate re-render to update selection highlighting
            StateHasChanged();
        }
        catch (Exception ex)
        {
            // Log error but don't crash the UI
            Console.WriteLine($"Error in HandleTopicSelected: {ex.Message}");
        }
    }
    
    private HashSet<string> SaveExpansionState()
    {
        var expandedPaths = new HashSet<string>();
        if (RootNodes != null && RootNodes.Count > 0)
        {
            CollectExpandedPaths(RootNodes, expandedPaths);
        }
        return expandedPaths;
    }
    
    private void CollectExpandedPaths(List<TopicTreeNodeModel> nodes, HashSet<string> expandedPaths)
    {
        foreach (var node in nodes)
        {
            if (node.IsExpanded)
            {
                expandedPaths.Add(node.FullPath);
                CollectExpandedPaths(node.Children, expandedPaths);
            }
        }
    }
    
    private void RestoreExpansionState(HashSet<string> expandedPaths)
    {
        foreach (var path in expandedPaths)
        {
            if (NodeLookup.TryGetValue(path, out var node))
            {
                node.IsExpanded = true;
                if (node.HasChildren && !node.ChildrenLoaded)
                {
                    LoadChildren(node);
                }
            }
        }
    }

    public class TopicTreeNodeModel
    {
        public string Name { get; set; } = string.Empty;
        public string FullPath { get; set; } = string.Empty;
        public List<TopicTreeNodeModel> Children { get; set; } = new();
        public TopicInfo? Topic { get; set; } // Only set for leaf nodes
        public bool IsExpanded { get; set; } = false; // Collapsed by default
        public bool HasChildren { get; set; } = false;
        public bool ChildrenLoaded { get; set; } = false;
        public bool HasData => Topic != null;
        public bool IsBlinking { get; set; } = false;
        public bool IsLoadingChildren { get; set; } = false;
    }
} 