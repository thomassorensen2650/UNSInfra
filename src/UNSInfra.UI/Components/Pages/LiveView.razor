@page "/liveview"
@using UNSInfra.Services.TopicBrowser
@using UNSInfra.Models.Hierarchy
@inject ITopicBrowserService TopicBrowserService
@implements IDisposable

<PageTitle>Live View</PageTitle>

<div class="liveview-container">
    <div class="topics-section">
        <div class="d-flex justify-content-between align-items-center mb-2">
            <h5 class="mb-0">Topics</h5>
            @if (_isLoadingTopics)
            {
                <div class="d-flex align-items-center">
                    <div class="spinner-border spinner-border-sm me-2" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <small class="text-muted">Updating...</small>
                </div>
            }
        </div>
        <div class="tree-container">
            @if (_isInitialLoad && Topics.Count == 0)
            {
                <div class="d-flex align-items-center justify-content-center py-4">
                    <div class="spinner-border spinner-border-sm me-2" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <span class="text-muted">Loading topics...</span>
                </div>
            }
            else
            {
                <TopicTree @ref="TopicTreeComponent" Topics="Topics" HighlightedPaths="HighlightedPaths" OnTopicSelected="OnTopicSelected" OnAddDataToNamespace="OnAddDataToNamespace" />
            }
        </div>
    </div>
    <div class="payload-section">
        <h5 class="mb-2">Payload</h5>
        <div class="payload-container">
            @if (SelectedTopic != null && SelectedPayload != null)
            {
                <pre class="payload-content">@System.Text.Json.JsonSerializer.Serialize(SelectedPayload, new System.Text.Json.JsonSerializerOptions { WriteIndented = true})</pre>
            }
            else if (SelectedTopic != null && SelectedPayload == null)
            {
                <div class="d-flex align-items-center">
                    <div class="spinner-border spinner-border-sm me-2" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <span class="text-muted">Loading payload...</span>
                </div>
            }
            else
            {
                <p class="text-muted">Select a topic to view its payload.</p>
            }
        </div>
        
        @if (SelectedTopic != null)
        {
            <div class="mt-3">
                <TopicMetadataEditor SelectedTopic="SelectedTopic" OnTopicVerified="OnTopicVerified" OnTopicUpdated="OnTopicUpdated" />
            </div>
        }
    </div>
</div>

<!-- Add Data to Namespace Modal -->
@if (showAddDataModal)
{
    <div class="modal fade show d-block" tabindex="-1" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1050;">
        <div class="modal-dialog modal-lg modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Add Data to Namespace: @selectedNamespacePath</h5>
                    <button type="button" class="btn-close" @onclick="HideAddDataModal"></button>
                </div>
                <div class="modal-body">
                    <p class="text-muted mb-3">Select topics and folders from unverified data to add to this namespace:</p>
                    
                    <TopicSelectionTree RootNodes="topicTreeNodes" 
                                       SelectedTopics="selectedTopicsForNamespace" 
                                       OnSelectionChanged="OnTopicSelectionChanged" />
                    
                    @if (selectedTopicsForNamespace.Any())
                    {
                        <div class="mt-3">
                            <small class="text-success">
                                <i class="bi bi-check-circle me-1"></i>
                                @selectedTopicsForNamespace.Count topic(s) selected
                            </small>
                        </div>
                    }
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="HideAddDataModal">Cancel</button>
                    <button type="button" class="btn btn-success" @onclick="AddSelectedTopicsToNamespace" 
                            disabled="@(!selectedTopicsForNamespace.Any())">
                        Add @selectedTopicsForNamespace.Count Topic(s)
                    </button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    private List<TopicInfo> Topics = new();
    private HashSet<string> HighlightedPaths = new();
    private TopicInfo? SelectedTopic;
    private object? SelectedPayload;
    private bool _refreshScheduled = false;
    private DateTime _lastRefresh = DateTime.MinValue;
    private const int RefreshThrottleMs = 2000; // Limit UI updates to every 2 seconds for better performance
    private TopicTree? TopicTreeComponent;
    private bool _isLoadingTopics = false;
    private bool _isInitialLoad = true;
    
    // Add Data to Namespace functionality
    private bool showAddDataModal = false;
    private string selectedNamespacePath = "";
    private List<TopicInfo>? availableTopicsForNamespace;
    private HashSet<TopicInfo> selectedTopicsForNamespace = new();
    private List<TopicSelectionTree.TopicSelectionTreeNode>? topicTreeNodes;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await RefreshTopics();
            TopicBrowserService.TopicDataUpdated += OnTopicDataUpdated;
            TopicBrowserService.TopicAdded += OnTopicAdded;
            
            // Enable periodic refresh timer for real-time data updates (less aggressive)
            _ = Task.Run(async () =>
            {
                var refreshCount = 0;
                while (true)
                {
                    await Task.Delay(RefreshThrottleMs);
                    refreshCount++;
                    
                    // Only refresh every 3rd cycle to reduce SignalR load
                    if (refreshCount % 3 == 0)
                    {
                        await ScheduleRefresh();
                    }
                }
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing LiveView: {ex.Message}");
            _isInitialLoad = false;
            StateHasChanged();
        }
    }

    private async Task RefreshTopics()
    {
        try
        {
            // Only show loading indicator for non-initial loads (updates)
            if (!_isInitialLoad)
            {
                _isLoadingTopics = true;
                StateHasChanged(); // Show updating indicator
            }
            
            var newTopics = (await TopicBrowserService.GetLatestTopicStructureAsync()).ToList();
            
            // Update topics smoothly
            Topics = newTopics;
            _lastRefresh = DateTime.UtcNow;
            _isInitialLoad = false;
            
            if (_isLoadingTopics)
            {
                _isLoadingTopics = false;
                StateHasChanged(); // Hide updating indicator
            }
            else
            {
                StateHasChanged(); // Initial load - just show topics
            }
        }
        catch (Exception ex)
        {
            // Log error but don't crash the UI
            Console.WriteLine($"Error refreshing topics: {ex.Message}");
            _isLoadingTopics = false;
            _isInitialLoad = false;
            StateHasChanged();
        }
    }

    private void OnTopicDataUpdated(object? sender, TopicDataUpdatedEventArgs e)
    {
        // Find the topic configuration to get the correct path for blinking
        var topicInfo = Topics.FirstOrDefault(t => t.Topic == e.Topic);
        if (topicInfo != null)
        {
            string fullPath;
            
            // Use different path structure based on verification status
            if (topicInfo.IsVerified)
            {
                // For verified topics, build path from hierarchical path parts
                var pathParts = new[]
                {
                    topicInfo.Path.Enterprise,
                    topicInfo.Path.Site,
                    topicInfo.Path.Area,
                    topicInfo.Path.WorkCenter,
                    topicInfo.Path.WorkUnit,
                    topicInfo.Path.Property
                }.Where(p => !string.IsNullOrEmpty(p)).ToArray();
                fullPath = string.Join("/", pathParts);
            }
            else
            {
                // For unverified topics, use the raw topic path under unverified section
                const string unverifiedSectionName = "🔍 Unverified Topics";
                fullPath = $"{unverifiedSectionName}/{topicInfo.SourceType}/{topicInfo.Topic}";
            }
            
            // Start blinking animation in the tree - this is sufficient for showing updates
            if (TopicTreeComponent != null)
            {
                _ = InvokeAsync(async () => await TopicTreeComponent.BlinkNode(fullPath));
            }
        }
        
        // Remove the persistent yellow highlighting to reduce visual noise
        // The blinking animation already shows data updates effectively
        
        // DATA UPDATES should NOT trigger topic structure refresh
        // The hierarchical paths are static and only change via manual edits
        // No need to call ScheduleThrottledUpdate() here
    }

    private void OnTopicAdded(object? sender, TopicAddedEventArgs e)
    {
        Topics.Add(e.TopicInfo);
        
        // Trigger blinking for the new topic
        string fullPath;
        
        // Use different path structure based on verification status
        if (e.TopicInfo.IsVerified)
        {
            // For verified topics, build path from hierarchical path parts
            var pathParts = new[]
            {
                e.TopicInfo.Path.Enterprise,
                e.TopicInfo.Path.Site,
                e.TopicInfo.Path.Area,
                e.TopicInfo.Path.WorkCenter,
                e.TopicInfo.Path.WorkUnit,
                e.TopicInfo.Path.Property
            }.Where(p => !string.IsNullOrEmpty(p)).ToArray();
            fullPath = string.Join("/", pathParts);
        }
        else
        {
            // For unverified topics, use the raw topic path under unverified section
            const string unverifiedSectionName = "🔍 Unverified Topics";
            fullPath = $"{unverifiedSectionName}/{e.TopicInfo.SourceType}/{e.TopicInfo.Topic}";
        }
        
        if (TopicTreeComponent != null)
        {
            _ = InvokeAsync(async () => await TopicTreeComponent.BlinkNode(fullPath));
        }
        
        ScheduleThrottledUpdate();
    }

    private void ScheduleThrottledUpdate()
    {
        if (!_refreshScheduled)
        {
            _refreshScheduled = true;
            InvokeAsync(async () =>
            {
                await Task.Delay(50); // Small delay to batch multiple rapid updates
                _refreshScheduled = false;
                StateHasChanged();
            });
        }
    }

    private async Task ScheduleRefresh()
    {
        // Only refresh topics periodically if there's been significant activity
        if (DateTime.UtcNow - _lastRefresh > TimeSpan.FromSeconds(5))
        {
            await InvokeAsync(async () =>
            {
                await RefreshTopics();
                StateHasChanged();
            });
        }
    }

    private async Task OnTopicSelected(TopicInfo topic)
    {
        // Immediately update UI to show loading state
        SelectedTopic = topic;
        SelectedPayload = null; // This triggers the loading spinner
        StateHasChanged(); // Force immediate UI update
        
        try
        {
            // Since we're using EventDrivenTopicBrowserService with in-memory cache,
            // this should be fast. No need for Task.Run.
            var data = await TopicBrowserService.GetDataForTopicAsync(topic.Topic);
            
            // Only update if still selected (user didn't click another topic)
            if (SelectedTopic?.Topic == topic.Topic)
            {
                SelectedPayload = data?.Value ?? "No data available";
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            // On error, still clear the loading state
            if (SelectedTopic?.Topic == topic.Topic)
            {
                SelectedPayload = $"Error loading payload: {ex.Message}";
                StateHasChanged();
            }
        }
    }

    private async Task OnTopicVerified()
    {
        // Update the current selected topic's verification status immediately
        if (SelectedTopic != null)
        {
            SelectedTopic.IsVerified = true;
            
            // Also update the topic in the Topics list used by the tree
            var topicInList = Topics.FirstOrDefault(t => t.Topic == SelectedTopic.Topic);
            if (topicInList != null)
            {
                topicInList.IsVerified = true;
            }
            
            // Force an immediate UI update to show verification change in tree
            StateHasChanged();
            
            // Small delay to ensure the tree component processes the change
            await Task.Delay(50);
        }
        
        // Also refresh the entire topics list to get the latest data from repository
        // This ensures we have the most up-to-date data and the tree will rebuild
        await RefreshTopics();
    }

    private async Task OnTopicUpdated()
    {
        // Force a full refresh to get the updated configuration from the repository
        // This ensures hierarchical path changes are reflected in the tree
        await RefreshTopics();
    }

    private async Task OnAddDataToNamespace((string namespacePath, List<TopicInfo> topics) args)
    {
        selectedNamespacePath = args.namespacePath;
        availableTopicsForNamespace = args.topics;
        selectedTopicsForNamespace.Clear();
        
        // Build tree structure from unverified topics
        BuildTopicSelectionTree();
        
        showAddDataModal = true;
        StateHasChanged();
    }

    private void HideAddDataModal()
    {
        showAddDataModal = false;
        selectedTopicsForNamespace.Clear();
        StateHasChanged();
    }

    private async Task OnTopicSelectionChanged(HashSet<TopicInfo> selectedTopics)
    {
        selectedTopicsForNamespace = selectedTopics;
        StateHasChanged();
    }
    
    private void BuildTopicSelectionTree()
    {
        if (availableTopicsForNamespace == null || !availableTopicsForNamespace.Any())
        {
            topicTreeNodes = new List<TopicSelectionTree.TopicSelectionTreeNode>();
            return;
        }
        
        var nodeDict = new Dictionary<string, TopicSelectionTree.TopicSelectionTreeNode>();
        var rootNodes = new List<TopicSelectionTree.TopicSelectionTreeNode>();
        
        // Group topics by source type first
        var topicsBySourceType = availableTopicsForNamespace.GroupBy(t => t.SourceType).ToList();
        
        foreach (var sourceGroup in topicsBySourceType)
        {
            var sourceType = sourceGroup.Key;
            var sourceNode = new TopicSelectionTree.TopicSelectionTreeNode
            {
                Name = sourceType,
                FullPath = sourceType,
                IsFolder = true,
                Children = new List<TopicSelectionTree.TopicSelectionTreeNode>()
            };
            
            rootNodes.Add(sourceNode);
            nodeDict[sourceType] = sourceNode;
            
            // Build folder structure for each topic within this source type
            foreach (var topic in sourceGroup)
            {
                var topicParts = topic.Topic.Split('/', StringSplitOptions.RemoveEmptyEntries);
                
                if (topicParts.Length == 1)
                {
                    // Simple topic - add directly to source node
                    var topicNode = new TopicSelectionTree.TopicSelectionTreeNode
                    {
                        Name = topic.Topic,
                        FullPath = $"{sourceType}/{topic.Topic}",
                        IsFolder = false,
                        Topic = topic
                    };
                    sourceNode.Children.Add(topicNode);
                }
                else
                {
                    // Nested topic - build folder structure
                    string currentPath = sourceType;
                    var currentParent = sourceNode;
                    
                    for (int i = 0; i < topicParts.Length; i++)
                    {
                        var part = topicParts[i];
                        var partPath = $"{currentPath}/{part}";
                        
                        if (i == topicParts.Length - 1)
                        {
                            // This is the final part - create topic node
                            var topicNode = new TopicSelectionTree.TopicSelectionTreeNode
                            {
                                Name = part,
                                FullPath = partPath,
                                IsFolder = false,
                                Topic = topic
                            };
                            currentParent.Children.Add(topicNode);
                        }
                        else
                        {
                            // This is a folder - create or reuse folder node
                            if (!nodeDict.TryGetValue(partPath, out var folderNode))
                            {
                                folderNode = new TopicSelectionTree.TopicSelectionTreeNode
                                {
                                    Name = part,
                                    FullPath = partPath,
                                    IsFolder = true,
                                    Children = new List<TopicSelectionTree.TopicSelectionTreeNode>()
                                };
                                currentParent.Children.Add(folderNode);
                                nodeDict[partPath] = folderNode;
                            }
                            
                            currentParent = folderNode;
                            currentPath = partPath;
                        }
                    }
                }
            }
        }
        
        topicTreeNodes = rootNodes;
    }

    private async Task AddSelectedTopicsToNamespace()
    {
        try
        {
            Console.WriteLine($"Adding {selectedTopicsForNamespace.Count} topics to namespace: {selectedNamespacePath}");
            
            foreach (var topic in selectedTopicsForNamespace)
            {
                Console.WriteLine($"  - Processing topic: {topic.Topic} from {topic.SourceType}");
                
                // Get the current topic configuration
                var currentConfig = await TopicBrowserService.GetTopicConfigurationAsync(topic.Topic);
                if (currentConfig != null)
                {
                    // Update the configuration to map to the namespace
                    currentConfig.NSPath = selectedNamespacePath;
                    currentConfig.IsVerified = true;
                    currentConfig.ModifiedAt = DateTime.UtcNow;
                    
                    // Add metadata about the namespace assignment
                    currentConfig.Metadata["assigned_to_namespace"] = selectedNamespacePath;
                    currentConfig.Metadata["assigned_at"] = DateTime.UtcNow.ToString("O");
                    currentConfig.Metadata["assigned_by"] = "user";
                    
                    // Update the topic configuration
                    await TopicBrowserService.UpdateTopicConfigurationAsync(currentConfig);
                    
                    Console.WriteLine($"  - Successfully updated topic configuration for {topic.Topic}");
                }
                else
                {
                    Console.WriteLine($"  - Warning: Could not find topic configuration for {topic.Topic}");
                }
            }
            
            HideAddDataModal();
            
            // Refresh the topics to show the changes
            await RefreshTopics();
            
            Console.WriteLine($"Successfully added {selectedTopicsForNamespace.Count} topics to namespace: {selectedNamespacePath}");
            
            // Force the NS tree editor to refresh by triggering a small delay and manual refresh
            await Task.Delay(500); // Give the database time to update
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error adding topics to namespace: {ex.Message}");
        }
    }

    private static List<string> GetAllParentPaths(HierarchicalPath path)
    {
        var parts = new[]
        {
            path.Enterprise,
            path.Site,
            path.Area,
            path.WorkCenter,
            path.WorkUnit,
            path.Property
        };
        var result = new List<string>();
        string current = "";
        for (int i = 0; i < parts.Length; i++)
        {
            if (string.IsNullOrEmpty(parts[i])) break;
            current = string.IsNullOrEmpty(current) ? parts[i] : $"{current}/{parts[i]}";
            result.Add(current);
        }
        return result;
    }

    public void Dispose()
    {
        TopicBrowserService.TopicDataUpdated -= OnTopicDataUpdated;
        TopicBrowserService.TopicAdded -= OnTopicAdded;
    }
}

<style>
/* Full height layout */
.liveview-container {
    display: flex;
    height: calc(100vh - 3.5rem); /* Subtract the top-row height */
    gap: 1rem;
}

.topics-section {
    flex: 0 0 35%;
    display: flex;
    flex-direction: column;
    min-width: 0; /* Allows flex shrinking */
}

.payload-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0; /* Allows flex shrinking */
}

.tree-container {
    flex: 1;
    overflow-y: auto;
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    padding: 0.75rem;
    background-color: #fff;
    min-height: 0; /* Allows flex shrinking */
}

.payload-container {
    flex: 1;
    overflow-y: auto;
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    padding: 0.75rem;
    background-color: #f8f9fa;
    margin-bottom: 1rem;
    transition: border-color 0.15s ease-in-out;
    min-height: 200px;
    max-height: 400px; /* Fixed height to leave room for metadata */
}

.payload-container:has(.spinner-border) {
    border-color: #0d6efd;
    box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
}

.payload-content {
    margin: 0;
    background-color: transparent;
    border: none;
    padding: 0;
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 0.875rem;
    line-height: 1.4;
}

/* Custom scrollbar styling */
.tree-container::-webkit-scrollbar,
.payload-container::-webkit-scrollbar {
    width: 8px;
}

.tree-container::-webkit-scrollbar-track,
.payload-container::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

.tree-container::-webkit-scrollbar-thumb,
.payload-container::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 4px;
}

.tree-container::-webkit-scrollbar-thumb:hover,
.payload-container::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}

/* Responsive layout for smaller screens */
@@media (max-width: 768px) {
    .liveview-container {
        flex-direction: column;
        height: auto;
        min-height: calc(100vh - 3.5rem);
    }
    
    .topics-section, 
    .payload-section {
        min-height: 400px;
    }
}
</style>